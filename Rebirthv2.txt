getgenv().Name = getgenv().Name or "BhopGod & AirJordan Made This!"
getgenv().Depth = getgenv().Depth or 410
getgenv().SellThreshold = getgenv().SellThreshold or 30000

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local VirtualUser = game:GetService("VirtualUser")
local LocalPlayer = Players.LocalPlayer

-- simple split (kept similar to your provided logic)
local function split(s, delimiter)
    local result = {}
    for match in (s .. delimiter):gmatch("(.-)" .. delimiter) do
        table.insert(result, match)
    end
    return result
end

local function setupAntiAfk()
    VirtualUser:CaptureController()
    LocalPlayer.Idled:Connect(function()
        VirtualUser:CaptureController()
        VirtualUser:ClickButton2(Vector2.new())
    end)
    -- alternate VirtualUser pattern seen in original
    LocalPlayer.Idled:Connect(function()
        VirtualUser:Button2Down(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
        task.wait(1)
        VirtualUser:Button2Up(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
    end)
end

local function waitForGameReady()
    repeat task.wait() until game:IsLoaded()
    local screenGui = LocalPlayer.PlayerGui:WaitForChild("ScreenGui")

    while screenGui.LoadingFrame.BackgroundTransparency == 0 do
        for _, connection in pairs(getconnections(screenGui.LoadingFrame.Quality.LowQuality.MouseButton1Down)) do
            pcall(function() connection:Fire() end)
        end
        task.wait()
    end

    repeat task.wait(1) until (pcall(function() LocalPlayer.leaderstats:WaitForChild("Blocks Mined") end)
        and pcall(function() screenGui.StatsFrame.Coins:FindFirstChild("Amount") end)
        and screenGui.StatsFrame.Tokens.Amount.Text ~= "Loading...")

    pcall(function()
        screenGui.TeleporterFrame:Destroy()
        screenGui.StatsFrame.Sell:Destroy()
        screenGui.MainButtons.Surface:Destroy()
    end)

    return screenGui
end

local function getRemote()
    local ok, rem = pcall(function()
        local data = getsenv(LocalPlayer.PlayerGui.ScreenGui.ClientScript).displayCurrent
        local values = getupvalue(data, 8)
        local remote = values and values["RemoteEvent"]
        data, values = nil, nil
        return remote
    end)
    if ok then return rem end
    return nil
end

local function createForcePlatform(pos)
    local part = Instance.new("Part", workspace)
    part.Anchored = true
    part.Size = Vector3.new(10, 0.5, 100)
    part.Material = Enum.Material.ForceField
    part.Position = pos
    return part
end

local function moveToLavaSpawn(remote, humanoidRootPart)
    if not remote or not humanoidRootPart then return end
    local char = LocalPlayer.Character
    if char and char:FindFirstChild("Humanoid") then
        char.Humanoid.WalkSpeed = 0
        char.Humanoid.JumpPower = 0
    end
    humanoidRootPart.Anchored = true
    pcall(function() remote:FireServer("MoveTo", {{"LavaSpawn"}}) end)
    local platform = createForcePlatform(Vector3.new(21, 9.5, 26285))
    task.wait(1)
    humanoidRootPart.Anchored = false
    while humanoidRootPart.Position.Z > 26220 do
        humanoidRootPart.CFrame = CFrame.new(Vector3.new(humanoidRootPart.Position.X, 13.05, humanoidRootPart.Position.Z - 0.5))
        task.wait()
    end
    humanoidRootPart.CFrame = CFrame.new(18, 10, 26220)
    if platform and platform.Parent then pcall(function() platform:Destroy() end) end
end

local function mineUntilDepth(remote, humanoidRootPart, screenGui, targetDepth)
    if not remote or not humanoidRootPart or not screenGui then return end
    local runService = RunService.Heartbeat
    local depthText = split(screenGui.TopInfoFrame.Depth.Text, " ")
    while tonumber(depthText[1]) < targetDepth do
        local min = humanoidRootPart.CFrame + Vector3.new(-1, -10, -1)
        local max = humanoidRootPart.CFrame + Vector3.new(1, 0, 1)
        local region = Region3.new(min.Position, max.Position)
        local parts = workspace:FindPartsInRegion3WithWhiteList(region, {workspace.Blocks}, 5)
        for _, block in pairs(parts) do
            pcall(function() remote:FireServer("MineBlock", {{block.Parent}}) end)
            runService:Wait()
        end
        depthText = split(screenGui.TopInfoFrame.Depth.Text, " ")
        task.wait()
    end
end

local function startRebirthHandler(remote)
    if not remote then return end
    local coinsAmountLbl = LocalPlayer.leaderstats and LocalPlayer.leaderstats:FindFirstChild("Coins")
    local rebirthsAmount = LocalPlayer.leaderstats and LocalPlayer.leaderstats:FindFirstChild("Rebirths")
    if not rebirthsAmount or not coinsAmountLbl then return end

    local function getCoinsAmount()
        local amount = tostring(coinsAmountLbl.Value)
        amount = amount:gsub(',', '')
        return tonumber(amount) or 0
    end

    RunService:BindToRenderStep("Rebirth", Enum.RenderPriority.First.Value, function()
        if getCoinsAmount() >= (10000000 * (rebirthsAmount.Value + 1)) then
            -- preserve the aggressive rebirth calls from your logic
            pcall(function()
                remote:FireServer("Rebirth", {{}})
                remote:FireServer("Rebirth", {{}})
            end)
            task.defer(function()
                pcall(function()
                    remote:FireServer("Rebirth", {{}})
                    remote:FireServer("Rebirth", {{}})
                end)
            end)
        end
    end)
end

local function startMainLoop(remote, screenGui, humanoidRootPart, depthTarget, sellThreshold)
    if not remote or not screenGui or not humanoidRootPart then return end
    local recovering = false

    -- depth change recovery
    local depthAmountLbl = screenGui.TopInfoFrame.Depth
    depthAmountLbl.Changed:Connect(function()
        local depthText = split(depthAmountLbl.Text, " ")
        if tonumber(depthText[1]) >= 1500 and not recovering then
            recovering = true
            moveToLavaSpawn(remote, humanoidRootPart)
            task.wait(5)
            recovering = false
        end
    end)

    local inventoryLbl = screenGui.StatsFrame2.Inventory.Amount
    local function getInventoryAmount()
        local amount = tostring(inventoryLbl.Text)
        amount = amount:gsub('%s+', ''):gsub(',', '')
        local inv = amount:split("/")
        return tonumber(inv[1]) or 0
    end

    local sellArea = CFrame.new(41.96064, 14, -1239.64648)

    local function setPlatformStand(state)
        local char = LocalPlayer.Character
        if char and char:FindFirstChild("Humanoid") then
            char.Humanoid.PlatformStand = state
            if state and humanoidRootPart then humanoidRootPart.Velocity = Vector3.new(0,0,0) end
        end
    end

    while true do
        if humanoidRootPart then
            local minp = humanoidRootPart.CFrame.Position + Vector3.new(-10, -10, -10)
            local maxp = humanoidRootPart.CFrame.Position + Vector3.new(10, 10, 10)
            local region = Region3.new(minp, maxp)
            local parts = workspace:FindPartsInRegion3WithWhiteList(region, {workspace.Blocks}, 100)

            for _, block in pairs(parts) do
                if block:IsA("BasePart") then
                    pcall(function() remote:FireServer("MineBlock", {{block.Parent}}) end)
                    repeat
                        RunService.Heartbeat:Wait()
                    until not recovering
                end

                if getInventoryAmount() >= sellThreshold then
                    if humanoidRootPart then
                        local savedPosition = humanoidRootPart.Position
                        while getInventoryAmount() >= sellThreshold do
                            humanoidRootPart.CFrame = sellArea
                            pcall(function()
                                remote:FireServer("SellItems", {{}})
                                remote:FireServer("SellItems", {{}})
                                remote:FireServer("SellItems", {{}})
                            end)
                            task.defer(function()
                                pcall(function()
                                    remote:FireServer("SellItems", {{}})
                                    remote:FireServer("SellItems", {{}})
                                end)
                            end)
                            RunService.RenderStepped:Wait()
                        end

                        setPlatformStand(true)
                        local startTime = os.time()
                        while (humanoidRootPart.Position - savedPosition).Magnitude > 1 do
                            humanoidRootPart.CFrame = CFrame.new(18, savedPosition.Y + 2, 26220)
                            RunService.Heartbeat:Wait()
                            if os.time() - startTime > 5 then break end
                        end
                        setPlatformStand(false)
                    end
                end
            end
        end
        RunService.Heartbeat:Wait()
    end
end

-- Entrypoint that wires everything using the provided logic
local function main()
    setupAntiAfk()
    localPlayer = LocalPlayer

    -- wait for UI ready and cleanup
    local screenGui = waitForGameReady()

    -- set player tags
    pcall(function()
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head") then
            LocalPlayer.Character.Head.CustomPlayerTag.PlayerName.Text = getgenv().Name
            LocalPlayer.Character.Head.CustomPlayerTag.MinerRank.Text = getgenv().Name
        end
    end)

    -- grab humanoid root part reference
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

    -- monitor workspace collapse (preserve original behaviour: restart main on collapse)
    workspace.Collapsed.Changed:Connect(function()
        if workspace.Collapsed.Value then
            -- restart logic similar to provided script
            spawn(function() main() end)
        end
    end)

    -- obtain remote
    local remote = getRemote()

    -- run external loaders (kept as in your logic)
    pcall(function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/ProdHallow/Miningsimrebirthtracker/main/miningsimrebirthtracker", true))()
    end)
    task.wait(1)
    pcall(function()
        loadstring(game:HttpGet('https://raw.githubusercontent.com/ProdHallow/DeleteAssetMinSim1/main/deleteassetsminingsim'))()
    end)
    task.wait(1)
    pcall(function()
        loadstring(game:HttpGet('https://raw.githubusercontent.com/ProdHallow/rebirthtracker/main/rebirthtracker'))()
    end)
    task.wait(1)

    -- initial move and mine pass (preserve behavior)
    moveToLavaSpawn(remote, humanoidRootPart)
    mineUntilDepth(remote, humanoidRootPart, screenGui, getgenv().Depth)

    -- start rebirth handler
    startRebirthHandler(remote)

    -- start main loop (mining, selling, recovery)
    startMainLoop(remote, screenGui, humanoidRootPart, getgenv().Depth, getgenv().SellThreshold)
end

-- run
spawn(main)
